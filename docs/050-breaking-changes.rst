********************************
Solidity v0.5.0 Breaking Changes
********************************

This section highlights the main breaking changes introduced in Solidity
version 0.5.0, along with the reasoning behind the changes and how to update
affected code.
For the full list check
`the release changelog <https://github.com/ethereum/solidity/releases/tag/v0.5.0>`_.

Semantic Only Changes
=====================

This section lists the changes that are semantic-only, thus potentially
hiding new and different behaviors in previous code.

* Signed right shift now uses proper arithmetic shift, i.e. rounding towards
  negative infinity. Signed and unsigned shift will have dedicated opcodes in
  Constantinople, and are emulated by Solidity for the moment.

* The ``continue`` statement in a ``do...while`` loop now jumps to the
  condition, which is the common behavior in such cases. It used to jump to the
  loop body. Thus, if the condition is false, the loop terminates.

* The ``call`` function does not pad anymore when given a single ``bytes``
  parameter.

* The ABI encoder now properly pads data from calldata (``msg.data`` and
  external function parameters). For unpadded encoding, use
  ``abi.encodePacked``.

* The generated bytecode reverts at runtime if passed calldata is too short
  or points out of bounds. This is done inside the ``ABI decoder`` and
  therefore also applies to ``abi.decode()``.

* Pure and view functions are now called using the opcode ``STATICCALL``
  instead of ``CALL``, which disallows state changes on the EVM level.

Semantic and Syntactic Changes
==============================

This section highlights changes that affect syntax and semantics.

* The functions ``.call()``, ``.callcode()``, ``.delegatecall()`,
  ``staticcall()``, ``keccak256()``, ``sha256()`` and ``ripemd160()`` now
  accept only a single ``bytes`` argument. Moreover, the argument is not
  padded. This was changed to make more explicit and clear how the arguments
  are concatenated. Change every ``.call()`` (and family) to a ``.call("")``
  and every ``.call(signature, a, b, c)`` to use
  ``.call(abi.encodeWithSignature(signature, a, b, c))`` (the last one only
  works for value types).  Change every ``keccak256(a, b, c)`` to
  ``keccak256(abi.encodePacked(a, b, c))``. Even though it is not a breaking
  change, it is suggested that developers change
  ``x.call(bytes4(keccak256("f(uint256)"), a, b)`` to
  ``x.call(abi.encodeWithSignature("f(uint256)", a, b))``.

* Functions ``.call()``, ``.callcode()``, ``.delegatecall()`` and
  ``.staticcall()`` now return ``(bool, bytes memory)``, since functions
  called with the opcode ``STATICCALL`` might need to return data.  Change
  ``bool success = otherContract.call("f")`` to ``(bool success, bytes memory
  data) = otherContract.call("f")``.

* Solidity now implements C99-style scoping rules for function local
  variables, that is, variables can only be used after they have been
  declared and only in the same or nested scopes. Variables declared in the
  initialization block of a ``for`` loop are valid at any point inside the
  loop.

Explicitness Requirements
=========================

This section lists changes where the code now needs to be more explicit.

* Explicit function visibility is now mandatory.  Add ``public`` to every
  function and constructor, and ``external`` to every fallback or interface
  function that does not specify its visibility already.

* Explicit data location for all variables of struct, array or mapping types is
  now mandatory. This is also applied to function parameters and return
  variables.  For example, change ``uint[] x = m_x`` to ``uint[] storage x =
  m_x``, and ``function f(uint[][] x)`` to ``function f(uint[][] memory x)``
  where ``memory`` is the data location and might be replaced by ``storage`` or
  ``calldata`` accordingly.  Note that ``external`` functions require
  parameters with a data location of ``calldata``.

* Variables of contract type do not contain ``address`` members anymore in
  order to separate the namespaces.  Therefore, it is now necessary to
  explicitly convert values of contract type to addresses before using an
  ``address`` member.  Example: if ``c`` is a contract, change
  ``c.transfer(...)`` to ``address(c).transfer(...)``.

* The ``address`` type  was split into ``address`` and ``address payable``,
  where only ``address payable`` provides the ``transfer`` function.  An
  ``address payable`` can be directly converted to an ``address``, but the
  other way around is not allowed. Converting ``address`` to ``address
  payable`` is possible via conversion through ``uint160``.

* Conversions between ``bytesX`` and ``uintY`` of different size are now
  disallowed due to ``bytesX`` padding on the right and ``uintY`` padding on
  the left which may cause unexpected conversion results.  The size must now be
  adjusted within the type before the conversion.  For example, you can convert
  a ``bytes4`` (4 bytes) to a ``uint64`` (8 bytes) by first converting the
  ``bytes4`` variable to ``bytes8`` and then to ``uint64``.

* Using ``msg.value`` in ``non-payable`` functions (or introducing it via a
  modifier) is disallowed as a security feature. Turn the function into
  ``payable`` or create a new internal function for the program logic that
  uses ``msg.value``.

* For clarity reasons, the command line interface now requires ``-`` if the
  standard input is used as source.

Deprecated Elements
===================

This section lists changes that deprecate prior features or syntax.  Note that
many of these changes were already enabled in the experimental mode
``v0.5.0``.

* The command line option ``--formal`` was removed. Formal verification is
  now enabled via ``pragma experimental SMTChecker;``.

* The command line option ``--julia`` was renamed to ``--yul`` due to the
  renaming of the intermediate language ``Julia`` to ``Yul``.

* Function ``callcode`` is now disallowed (in favor of ``delegatecall``. It
  is still possible to use it via inline assembly.

* Declaring empty structs is now disallowed for clarity.

* The ``var`` keyword is now disallowed.

* ``suicide`` is now disallowed (in favor of ``selfdestruct``).

* ``sha3`` is now disallowed (in favor of ``keccak256``).

* ``throw`` is now disallowed (in favor of ``revert``, ``require`` and
  ``assert``).

* The Json AST fields ``constant`` and ``payable`` were removed. The
  information is now present in the ``stateMutability`` field.

* The ``--clone-bin`` and ``--combined-json clone-bin`` command line options
  were removed.

* Using ``constant`` as function state mutability modifier is now disallowed.

* Assignments between tuples with different number of components is now
  disallowed.
  
* Values for constants that are not compile-time constants are disallowed.

* New keywords: ``calldata`` and ``constructor``.

* New reserved keywords: ``alias``, ``apply``, ``auto``, ``copyof``,
  ``define``, ``immutable``, ``implements``, ``macro``, ``mutable``,
  ``override``, ``partial``, ``promise``, ``reference``, ``sealed``,
  ``sizeof``, ``supports``, ``typedef`` and ``unchecked``.

* Boolean expressions cannot use arithmetic operations.

* The unit denomination ``years`` is now disallowed.

* Trailing dots that are not followed by a number are now disallowed.

* Remappings with empty prefix are disallowed.

* Combining hex numbers with unit denominations (e.g. ``0x1e wei``) is now
  disallowed.

* Tight packing of literals is now disallowed.

* Calling base constructors without parentheses is now disallowed.

* Empty return statements for functions with one or more return values are now
  disallowed.

* Empty tuple components are now disallowed.

* Multi-variable declarations with mismatching number of values are now
  disallowed.

* Specifying base constructor arguments multiple times in the same inheritance
  hierarchy is now disallowed.

* Calling a constructor with wrong argument count is now disallowed.

* Uninitialized storage variables are now disallowed.

* Detecting cyclic dependencies in variables and structs is limited in
  recursion to 256.

* The "loose assembly" syntax is now disallowed entirely, that is, jump labels,
  jumps and non-functional instructions cannot be used anymore.

* Explicit and implicit conversions from decimal literals to ``bytesXX`` types
  is now disallowed.

* Explicit and implicit conversions from hex literals to ``bytesXX`` types
  of different size is now disallowed.

* Functions without implementation cannot use modifiers anymore.

* Function types with named return values are now disallowed.

* The unary ``+`` operator is now disallowed.

* Single statement variable declarations inside if/while/for bodies that are
  not blocks are now disallowed.

Example
=======

The following example shows a contract and its updated version for Solidity
v0.5.0 with some of the changes listed in this section.

Old version:

::

   pragma solidity ^0.4.25;

   contract OtherContract {
      uint x;
      function f(uint y) external {
         x = y;
      }
      function() payable external {}
   }

   contract Old {
      OtherContract other;
      uint myNumber;

      function someInteger() internal returns (uint) { return 2; }

      // Function visibility not provided, not an error.
      // Function mutability not provided, not an error.
      function f(uint x) {
         // Var is fine in this version.
         var z = someInteger();
         x += z;
         // Throw is fine in this version.
         if (x > 100)
            throw;
         y = -3 >> 1;
         // y = -1 (wrong, should be -2)
         do {
            x += 1;
            if (x > 10) continue;
            // 'Continue' causes an infinite loop.
         } while (x < 11);
         // Call returns only a Bool.
         bool success = other.call("f");
         if (!success)
            revert();
         else {
            // Local variables could be declared after their use.
            int y;
         }
      }

      // No need for an explicit data location for 'arr'
      function g(uint[] arr, bytes8 x, OtherContract otherContract) public {
         otherContract.transfer(1 ether);

         // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
         // the first 4 bytes of x will be lost. This is dangerous
         // because bytesX are right padded.
         uint32 y = uint32(x);
         myNumber += y + msg.value;
      }
   }

New version:

::

   pragma solidity >0.4.25;

   contract OtherContract {
      uint x;
      function f(uint y) external {
         x = y;
      }
      function() payable external {}
   }

   contract New {
      OtherContract other;
      uint myNumber;

      function someInteger() internal returns (uint) { return 2; }

      // Function visibility must be specified.
      // Function mutability must be specified.
      function f(uint x) public returns (bytes memory) {
         // The type must now be explicitly given.
         uint z = someInteger();
         x += z;
         // Throw is now disallowed.
         require(x > 100);
         int y = -3 >> 1;
         // y = -2 (correct)
         do {
            x += 1;
            if (x > 10) continue;
            // 'Continue' jumps to the condition below.
         } while (x < 11);

         // Call returns (bool, bytes).
         // Data location must be specified.
         (bool success, bytes memory data) = address(other).call("f");
         if (!success)
            revert();
         return data;
      }

      using address_make_payable for address;
      // Data location for 'arr' must be specified
      function g(uint[] memory arr, bytes8 x, OtherContract otherContract, address unknownContract) public payable {
         // 'otherContract.transfer' is not provided.
         // Since the code of 'OtherContract' is known and has the fallback
         // function, address(otherContract) has type 'address payable'.
         address(otherContract).transfer(1 ether);

         // 'unknownContract.transfer' is not provided.
         // 'address(unknownContract).transfer' is not provided
         // since 'address(unknownContract)' is not 'address payable'.
         // If the function takes an 'address' which you want to send
         // funds to, you can convert it to 'address payable' via 'uint160'.
         // Note: This is not recommended and the explicit type
         // 'address payable' should be used whenever possible.
         // To increase clarity, we suggest the use of a library for
         // the conversion (provided after the contract in this example).
         address payable addr = unknownContract.make_payable();
         require(addr.send(1 ether));

         // Since uint32 (4 bytes) is smaller than bytes8 (8 bytes),
         // the conversion is not allowed.
         // We need to convert to a common size first:
         bytes4 x4 = bytes4(x); // Padding happens on the right
         uint32 y = uint32(x4); // Conversion is consistent
         // 'msg.value' cannot be used in a 'non-payable' function.
         // We need to make the function payable
         myNumber += y + msg.value;
      }
   }

   // We can define a library for explicitly converting ``address``
   // to ``address payable`` as a workaround.
   library address_make_payable {
      function make_payable(address x) internal pure returns (address payable) {
         return address(uint160(x));
      }
   }
